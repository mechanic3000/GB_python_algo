# Написать два алгоритма нахождения i-го по счёту простого числа.
# Функция нахождения простого числа должна принимать
# на вход натуральное и возвращать соответствующее простое число.
# Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
# Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.

import timeit
import cProfile


def eratospher_prime_finder(n, max_index):
    sieve = [i for i in range(max_index)]
    sieve[1] = 0

    prime = 2  # первое простое число
    k = 0  # счетчик простых чисел
    i = 2

    while k < n:
        if sieve[i] != 0:
            prime = i
            k += 1
            j = i * 2
            while j < max_index:
                sieve[j] = 0
                j += i
        i += 1

    return prime


def prime_finder(n):
    i = 2
    prime = 2
    k = 0
    while k < n:
        d = 2
        while i % d != 0:
            d += 1
        if d == i:
            prime = i
            k += 1
        i += 1

    return prime


print(timeit.timeit('eratospher_prime_finder(350, 2500)', number=100, globals=globals()))  # 0.139890532
print(timeit.timeit('prime_finder(350)', number=100, globals=globals()))  # 3.408291273


# ВЫВОД:
# Алгорим поиска простого числа "Решето Эратосфера" работает значительно быстрее, чем простой перебор.